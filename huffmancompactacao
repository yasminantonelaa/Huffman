#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define tam 256 // Define o número total de valores possíveis para um byte (0-255)

// Estrutura: dados_no
// Armazena as informações essenciais para cada nó da árvore:
// - byte: o valor do byte (0-255)
// - frequency: quantas vezes esse byte aparece no arquivo
// - frequency_prcnt: porcentagem que esse byte representa no arquivo
typedef struct {
    u_char byte;
    long int frequency;
    long double frequency_prcnt;
} dados_no;

// Estrutura: no_htr
// Representa um nó da árvore de Huffman:
// - data: ponteiro para os dados do byte (struct dados_no)
// - left: ponteiro para o filho esquerdo (bit 0)
// - right: ponteiro para o filho direito (bit 1)
typedef struct no_htr {
    void *data;
    struct no_htr *left;
    struct no_htr *right;
} no_htr;

// Estrutura: frequency_array
// Funciona como uma tabela de frequência dos bytes:
// - arr_bytes: array de ponteiros para dados_no (indexado pelo valor do byte)
// - status: indica se a posição está ocupada (true) ou não (false)
typedef struct {
    void *arr_bytes[tam];
    bool status[tam];
} frequency_array;

// Estrutura: heap
// Implementa uma heap mínima usada na construção da árvore:
// - size: número atual de elementos na heap
// - max_heap_size: capacidade máxima da heap
// - data: array de ponteiros para nós da árvore
typedef struct {
    int size, max_heap_size;
    void **data;
} heap;

// Estrutura: huffman_code
// Armazena o código Huffman para cada byte:
// - code: sequência de bits (0s e 1s) que representam o código
// - size: tamanho do código em bits
typedef struct {
    u_char code[tam];
    int size;
} huffman_code;

/* Função: alloc_heap
 * Aloca memória para uma nova heap mínima
 */
heap *alloc_heap(int size) {
    heap *new = malloc(sizeof(heap));
    new->data = malloc((size + 1) * sizeof(no_htr *));
    new->max_heap_size = size + 1;
    new->size = 0;
    return new;
}

/* Função: alloc_no_htr
 * Aloca memória para um novo nó da árvore de Huffman
 */
no_htr *alloc_no_htr(dados_no *data) {
    no_htr *new = malloc(sizeof(no_htr));
    new->data = data;
    new->left = NULL;
    new->right = NULL;
    return new;
}

/* Função: alloc_frequency_array
 * Aloca e inicializa um array de frequências
 */
frequency_array *alloc_frequency_array() {
    frequency_array *new = malloc(sizeof(frequency_array));
    
    // Loop para inicializar todas as posições do array
    for (int i = 0; i < tam; i++) {
        new->arr_bytes[i] = NULL;  // Inicializa o ponteiro como NULL
        new->status[i] = false;     // Marca a posição como não ocupada
    }
    return new;
}

/* Função: alloc_dados_no
 * Aloca memória para os dados de um nó
 */
dados_no* alloc_dados_no(u_char byte) {
    dados_no *new = malloc(sizeof(dados_no));
    new->byte = byte;
    new->frequency = 0;
    return new;
}

/* Função: swap
 * Troca dois ponteiros genéricos
 */
void swap(void **a, void **b) {
    void *z = *a;
    *a = *b;
    *b = z;
}

/* Função: get_parent_index
 * Calcula o índice do pai de um nó na heap
 */
int get_parent_index(heap *hp, int i) {
    return i >> 1; // Equivalente a i/2 (divisão inteira)
}

/* Função: get_left_index
 * Calcula o índice do filho esquerdo de um nó na heap
 */
int get_left_index(heap *hp, int i) {
    return i << 1; // Equivalente a 2*i
}

/* Função: get_right_index
 * Calcula o índice do filho direito de um nó na heap
 */
int get_right_index(heap *hp, int i) {
    return (i << 1) + 1; // Equivalente a 2*i + 1
}

/* Função: min_heapfy
 * Mantém a propriedade de heap mínima a partir de um nó
 */
void min_heapfy(heap *hp, int i) {
    int smallest;
    int left_index = get_left_index(hp, i);
    int right_index = get_right_index(hp, i);

    // Compara com o filho esquerdo
    if (left_index <= hp->size &&
        ((dados_no*)((no_htr*) hp->data[left_index])->data)->frequency < ((dados_no*)((no_htr*)hp->data[i])->data)->frequency) {
        smallest = left_index;
    } else {
        smallest = i;
    }

    // Compara com o filho direito
    if (right_index <= hp->size &&
        ((dados_no*)((no_htr*)hp->data[right_index])->data)->frequency < ((dados_no*) ((no_htr*)hp->data[smallest])->data)->frequency) {
        smallest = right_index;
    }

    // Se o menor não for o próprio nó, troca e continua heapificando
    if (smallest != i) {
        swap(&hp->data[i], &hp->data[smallest]);
        min_heapfy(hp, smallest);
    }
}

/* Função: dequeue
 * Remove e retorna o nó com menor frequência da heap
 */
no_htr *dequeue(heap *hp) {
    if (hp->size == 0) {
        return NULL;
    }

    no_htr *min = hp->data[1];
    hp->data[1] = hp->data[hp->size];
    hp->size--;
    min_heapfy(hp, 1);
    return min;
}

/* Função: enqueue
 * Insere um novo nó na heap mantendo a propriedade de heap mínima
 */
void enqueue(heap *hp, no_htr *item) {
    if (hp->size >= hp->max_heap_size) {
        printf("Heap Overflow");
        return;
    }

    hp->data[++hp->size] = item;
    int key_index = hp->size;
    int parent_index = get_parent_index(hp, hp->size);

    // Ajusta a heap subindo o nó inserido até sua posição correta
    while (parent_index > 0 &&
        ((dados_no*)((no_htr*)hp->data[key_index])->data)->frequency < ((dados_no*)((no_htr*)hp->data[parent_index])->data)->frequency) {
        swap(&hp->data[key_index], &hp->data[parent_index]);
        key_index = parent_index;
        parent_index = get_parent_index(hp, key_index);
    }
}

/* Função: desalloc_heap
 * Libera a memória alocada para a heap
 */
void desalloc_heap(heap **hp) {
    free((*hp)->data);
    free(*hp);
    *hp = NULL;
}

/* Função: ler
 * Lê um arquivo e conta a frequência de cada byte
 */
void ler(char arq[], heap **hp) {
    u_char c;
    FILE *file = fopen(arq, "rb");

    if (!file) {
        printf("ERRO LEITURA\nVERIFIQUE O NOME DO ARQUIVO\n");
        exit(1);
    }

    long int qtd_bytes = 0;
    int arr_size = 0;
    frequency_array *frequency = alloc_frequency_array();

    // Loop principal de leitura do arquivo
    while (fread(&c, sizeof(u_char), 1, file) == 1) {
        // Se o byte ainda não foi registrado
        if (!frequency->status[(int)c]) {
            dados_no *no_data = alloc_dados_no(c);
            frequency->arr_bytes[(int)c] = no_data;
            frequency->status[(int)c] = true;
            arr_size++;
        }
        // Incrementa a frequência do byte e o contador total
        ((dados_no *)frequency->arr_bytes[(int)c])->frequency++;
        qtd_bytes++;
    }

    fclose(file);
    *hp = alloc_heap(arr_size);

    // Loop para processar os bytes encontrados
    for (int i = 0; i < tam; i++) {
        if (frequency->status[i]) {
            // Calcula a porcentagem de ocorrência do byte
            ((dados_no *) frequency->arr_bytes[i])->frequency_prcnt = 
                (((dados_no *)frequency->arr_bytes[i])->frequency / (long double)qtd_bytes) * 100;
            // Cria um nó e insere na heap
            no_htr *temp_node = alloc_no_htr((dados_no *)frequency->arr_bytes[i]);
            enqueue(*hp, temp_node);
            frequency->arr_bytes[i] = NULL;
        }
    }

    free(frequency);
    printf("Tamanho do arquivo lido %ld bytes\n", qtd_bytes);
}

/* Função: build_huffman_tree
 * Constrói a árvore de Huffman a partir da heap
 */
no_htr* build_huffman_tree(heap *hp) {
    // Enquanto houver mais de um nó na heap
    while (hp->size > 1) {
        // Remove os dois nós com menores frequências
        no_htr *left = dequeue(hp);
        no_htr *right = dequeue(hp);
        
        // Cria um novo nó com a soma das frequências
        dados_no *new_data = malloc(sizeof(dados_no));
        new_data->byte = 0;
        new_data->frequency = ((dados_no*)left->data)->frequency + ((dados_no*)right->data)->frequency;
        
        no_htr *new_node = alloc_no_htr(new_data);
        new_node->left = left;
        new_node->right = right;
        
        // Insere o novo nó na heap
        enqueue(hp, new_node);
    }
    
    // Retorna o último nó restante (raiz da árvore)
    return dequeue(hp);
}

/* Função: generate_huffman_codes
 * Gera os códigos Huffman recursivamente
 */
void generate_huffman_codes(no_htr *root, huffman_code *codes, u_char *buffer, int top) {
    // Se existe filho esquerdo, adiciona 0 ao buffer e continua
    if (root->left) {
        buffer[top] = 0;
        generate_huffman_codes(root->left, codes, buffer, top + 1);
    }
    
    // Se existe filho direito, adiciona 1 ao buffer e continua
    if (root->right) {
        buffer[top] = 1;
        generate_huffman_codes(root->right, codes, buffer, top + 1);
    }
    
    // Se é uma folha (byte), armazena o código gerado
    if (!root->left && !root->right) {
        for (int i = 0; i < top; i++) {
            codes[((dados_no*)root->data)->byte].code[i] = buffer[i];
        }
        codes[((dados_no*)root->data)->byte].size = top;
    }
}

/* Função: write_huffman_tree
 * Escreve a árvore no arquivo de forma serializada
 */
void write_huffman_tree(FILE *output, no_htr *node) {
    // Se é uma folha, escreve 1 seguido do byte
    if (!node->left && !node->right) {
        fputc(1, output);
        fputc(((dados_no*)node->data)->byte, output);
    } 
    // Se é nó interno, escreve 0 e recursivamente os filhos
    else {
        fputc(0, output);
        write_huffman_tree(output, node->left);
        write_huffman_tree(output, node->right);
    }
}

/* Função: compress_file
 * Compacta o arquivo usando os códigos Huffman gerados
 */
void compress_file(char *input_file, char *output_file, huffman_code *codes, no_htr *huffman_tree) {
    FILE *input = fopen(input_file, "rb");
    FILE *output = fopen(output_file, "wb");
    
    if (!input || !output) {
        printf("Erro ao abrir os arquivos\n");
        return;
    }
    
    // Escreve o cabeçalho
    fprintf(output, ".huff");
    // Escreve a árvore serializada
    write_huffman_tree(output, huffman_tree);
    // Escreve o marcador de separação
    fputc(0xFF, output);
    
    u_char byte;
    u_char buffer = 0;
    int count = 0;
    
    // Loop de leitura e compactação do arquivo
    while (fread(&byte, sizeof(u_char), 1, input) == 1) {
        huffman_code code = codes[byte];
        
        // Para cada bit do código Huffman
        for (int i = 0; i < code.size; i++) {
            buffer = (buffer << 1) | code.code[i];
            count++;
            
            // Quando completa 8 bits, escreve no arquivo
            if (count == 8) {
                fputc(buffer, output);
                buffer = 0;
                count = 0;
            }
        }
    }
    
    // Escreve os bits restantes, se houver
    if (count > 0) {
        buffer <<= (8 - count);
        fputc(buffer, output);
    }
    
    fclose(input);
    fclose(output);
}

/* Função: free_huffman_tree
 * Libera memória da árvore de Huffman recursivamente
 */
void free_huffman_tree(no_htr *node) {
    if (node) {
        free_huffman_tree(node->left);
        free_huffman_tree(node->right);
        free(node->data);
        free(node);
    }
}

/* Função: main
 * Controla o fluxo principal do programa
 */
int main() {
    char arquivo[100];
    
    printf("Digite o nome do arquivo para compactar: \n");
    scanf("%99[^\n]", arquivo);
    getchar();
    
    heap *hp = NULL;
    ler(arquivo, &hp);
    
    no_htr *huffman_tree = build_huffman_tree(hp);
    
    huffman_code codes[tam] = {0};
    u_char buffer[tam];
    generate_huffman_codes(huffman_tree, codes, buffer, 0);
    
    char output_file[104];
    snprintf(output_file, sizeof(output_file), "%s.huff", arquivo);
    compress_file(arquivo, output_file, codes, huffman_tree);
    
    printf("Arquivo compactado com sucesso: %s\n", output_file);
    
    free_huffman_tree(huffman_tree);
    desalloc_heap(&hp);
    
    return 0;
}
